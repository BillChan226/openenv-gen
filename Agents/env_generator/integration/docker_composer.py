"""
DockerComposer Agent - Generates Docker orchestration files

This agent generates:
- docker-compose.yml for full stack orchestration
- Individual Dockerfiles for each service
- .env.example for environment variables
"""

from pathlib import Path
from typing import Any, Dict, List

import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from utils import (
    PlanningAgent,
    AgentConfig,
    AgentRole,
    AgentCapability,
    TaskMessage,
    ResultMessage,
    create_result_message,
)

from ..context import EnvGenerationContext


class DockerComposerAgent(PlanningAgent):
    """
    Agent for generating Docker orchestration files.
    
    Generates:
    - docker-compose.yml (full stack)
    - docker-compose.dev.yml (development)
    - .env.example
    - Dockerfiles for each service
    
    Usage:
        agent = DockerComposerAgent(config)
        await agent.initialize()
        
        files = await agent.generate_docker(context, output_dir)
    """
    
    def __init__(self, config: AgentConfig):
        super().__init__(config, role=AgentRole.SPECIALIST, enable_reasoning=True)
        
        self.add_capability(AgentCapability(
            name="docker_orchestration",
            description="Generate Docker orchestration files",
        ))
    
    async def on_initialize(self) -> None:
        """Initialize docker composer"""
        await super().on_initialize()
        self._logger.info("DockerComposerAgent initialized")
    
    async def generate_docker(
        self,
        context: EnvGenerationContext,
        output_dir: Path,
    ) -> Dict[str, str]:
        """
        Generate Docker orchestration files.
        
        Args:
            context: Environment generation context
            output_dir: Output directory
            
        Returns:
            Dict mapping file paths to content
        """
        files = {}
        
        # Generate docker-compose.yml
        files["docker-compose.yml"] = self._generate_docker_compose(context)
        
        # Generate docker-compose.dev.yml
        files["docker-compose.dev.yml"] = self._generate_docker_compose_dev(context)
        
        # Generate .env.example
        files[".env.example"] = self._generate_env_example(context)
        
        # Generate API Dockerfile
        files[f"{context.name}_api/Dockerfile"] = self._generate_api_dockerfile(context)
        
        # Generate OpenEnv Dockerfile
        files["openenv_adapter/Dockerfile"] = self._generate_openenv_dockerfile(context)
        
        # Generate .dockerignore
        files[".dockerignore"] = self._generate_dockerignore()
        
        # Generate Makefile for convenience
        files["Makefile"] = self._generate_makefile(context)
        
        # Write files
        for path, content in files.items():
            file_path = output_dir / path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content, encoding="utf-8")
        
        return files
    
    def _generate_docker_compose(self, context: EnvGenerationContext) -> str:
        """Generate docker-compose.yml"""
        return f'''# {context.display_name} Docker Compose Configuration
# Auto-generated by EnvGenerator Multi-Agent System

version: "3.8"

services:
  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    container_name: {context.name}-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${{POSTGRES_USER:-postgres}}
      POSTGRES_PASSWORD: ${{POSTGRES_PASSWORD:-postgres}}
      POSTGRES_DB: ${{POSTGRES_DB:-{context.name}}}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "${{DB_PORT:-5432}}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${{POSTGRES_USER:-postgres}}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - {context.name}-network

  # Backend API
  api:
    build:
      context: ./{context.name}_api
      dockerfile: Dockerfile
    container_name: {context.name}-api
    restart: unless-stopped
    environment:
      DATABASE_URL: postgresql://${{POSTGRES_USER:-postgres}}:${{POSTGRES_PASSWORD:-postgres}}@db:5432/${{POSTGRES_DB:-{context.name}}}
      SECRET_KEY: ${{SECRET_KEY:-change-me-in-production}}
      DEBUG: ${{DEBUG:-false}}
    ports:
      - "${{API_PORT:-{context.api_port}}}:{context.api_port}"
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{context.api_port}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - {context.name}-network

  # Frontend UI
  ui:
    build:
      context: ./{context.name}_ui
      dockerfile: Dockerfile
    container_name: {context.name}-ui
    restart: unless-stopped
    ports:
      - "${{UI_PORT:-{context.ui_port}}}:80"
    depends_on:
      - api
    networks:
      - {context.name}-network

  # OpenEnv Adapter (for RL training)
  openenv:
    build:
      context: .
      dockerfile: openenv_adapter/Dockerfile
    container_name: {context.name}-openenv
    restart: unless-stopped
    environment:
      API_BASE_URL: http://api:{context.api_port}
    ports:
      - "${{OPENENV_PORT:-{context.openenv_port}}}:{context.openenv_port}"
    depends_on:
      api:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{context.openenv_port}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - {context.name}-network

volumes:
  postgres_data:
    name: {context.name}-postgres-data

networks:
  {context.name}-network:
    name: {context.name}-network
'''
    
    def _generate_docker_compose_dev(self, context: EnvGenerationContext) -> str:
        """Generate docker-compose.dev.yml for development"""
        return f'''# {context.display_name} Development Docker Compose
# Usage: docker-compose -f docker-compose.dev.yml up

version: "3.8"

services:
  # Database only - for local development
  db:
    image: postgres:15-alpine
    container_name: {context.name}-db-dev
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: {context.name}
    volumes:
      - postgres_data_dev:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis (optional, for caching/sessions)
  redis:
    image: redis:7-alpine
    container_name: {context.name}-redis-dev
    ports:
      - "6379:6379"

volumes:
  postgres_data_dev:
    name: {context.name}-postgres-data-dev
'''
    
    def _generate_env_example(self, context: EnvGenerationContext) -> str:
        """Generate .env.example"""
        return f'''# {context.display_name} Environment Variables

# Database
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB={context.name}
DB_PORT=5432

# API
API_PORT={context.api_port}
SECRET_KEY=your-super-secret-key-change-in-production
DEBUG=false

# Frontend
UI_PORT={context.ui_port}

# OpenEnv
OPENENV_PORT={context.openenv_port}

# Optional: External services
# REDIS_URL=redis://localhost:6379
# S3_BUCKET=your-bucket
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
'''
    
    def _generate_api_dockerfile(self, context: EnvGenerationContext) -> str:
        """Generate API Dockerfile"""
        return f'''# {context.display_name} API Dockerfile

FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    libpq-dev \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home appuser && chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE {context.api_port}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{context.api_port}/health || exit 1

# Run server
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "{context.api_port}"]
'''
    
    def _generate_openenv_dockerfile(self, context: EnvGenerationContext) -> str:
        """Generate OpenEnv Dockerfile"""
        return f'''# {context.display_name} OpenEnv Adapter Dockerfile

FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip install --no-cache-dir \\
    fastapi>=0.104.0 \\
    uvicorn>=0.24.0 \\
    requests>=2.25.0 \\
    pydantic>=2.0.0

# Copy adapter code
COPY openenv_adapter ./openenv_adapter

# Create non-root user
RUN useradd --create-home appuser && chown -R appuser:appuser /app
USER appuser

# Expose OpenEnv port
EXPOSE {context.openenv_port}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{context.openenv_port}/health || exit 1

# Run OpenEnv server
CMD ["python", "-m", "uvicorn", "openenv_adapter.server.app:app", "--host", "0.0.0.0", "--port", "{context.openenv_port}"]
'''
    
    def _generate_dockerignore(self) -> str:
        """Generate .dockerignore"""
        return '''# Git
.git
.gitignore

# Python
__pycache__
*.py[cod]
*$py.class
*.so
.Python
.env
.venv
env/
venv/
.pytest_cache/
.mypy_cache/
*.egg-info/

# Node
node_modules/
npm-debug.log
yarn-error.log

# IDE
.idea/
.vscode/
*.swp
*.swo

# Build artifacts
build/
dist/
*.egg

# Test
.coverage
htmlcov/

# Documentation
docs/_build/
*.md

# OS
.DS_Store
Thumbs.db

# Docker
docker-compose*.yml
Dockerfile*
.dockerignore
'''
    
    def _generate_makefile(self, context: EnvGenerationContext) -> str:
        """Generate Makefile for convenience commands"""
        return f'''.PHONY: help build up down logs clean test dev

help:
	@echo "{context.display_name} - Available commands:"
	@echo "  make build    - Build all Docker images"
	@echo "  make up       - Start all services"
	@echo "  make down     - Stop all services"
	@echo "  make logs     - View service logs"
	@echo "  make clean    - Remove containers and volumes"
	@echo "  make test     - Run tests"
	@echo "  make dev      - Start development database only"

build:
	docker-compose build

up:
	docker-compose up -d

down:
	docker-compose down

logs:
	docker-compose logs -f

clean:
	docker-compose down -v --rmi local

test:
	docker-compose exec api pytest

dev:
	docker-compose -f docker-compose.dev.yml up -d

# Development shortcuts
api-shell:
	docker-compose exec api /bin/bash

db-shell:
	docker-compose exec db psql -U postgres -d {context.name}

# OpenEnv specific
openenv-test:
	curl http://localhost:{context.openenv_port}/health
	curl -X POST http://localhost:{context.openenv_port}/reset

# Database
db-migrate:
	docker-compose exec api alembic upgrade head

db-reset:
	docker-compose exec db psql -U postgres -c "DROP DATABASE IF EXISTS {context.name};"
	docker-compose exec db psql -U postgres -c "CREATE DATABASE {context.name};"
'''
    
    async def process_task(self, task: TaskMessage) -> ResultMessage:
        """Process docker generation task"""
        params = task.task_params
        context = params.get("context")
        output_dir = Path(params.get("output_dir", "./generated"))
        
        if not context:
            return create_result_message(
                source_id=self.agent_id,
                target_id=task.header.source_agent_id,
                task_id=task.task_id,
                success=False,
                error_message="Context required",
            )
        
        files = await self.generate_docker(context, output_dir)
        
        return create_result_message(
            source_id=self.agent_id,
            target_id=task.header.source_agent_id,
            task_id=task.task_id,
            success=True,
            result_data={"files": list(files.keys())},
        )

