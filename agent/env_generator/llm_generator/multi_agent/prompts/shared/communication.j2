{# Shared: Communication Tools and Patterns #}

{% macro communication_tools() %}
## Communication Tools

### Sending Messages
- `send_message(to_agent, content, msg_type, priority)` - Send to specific agent
- `broadcast(message)` - Send to all agents
- `ask_agent(agent_id, question)` - Ask and wait for answer
- `report_issue(issue, assign_to, severity)` - Report bugs to responsible agent

### Receiving Messages
- `check_inbox()` - Check for messages from other agents

### Message Status Tracking (NEW!)
- `get_message_status(message_id)` - Check if your message was delivered/read/responded
- `get_pending_replies()` - Get all messages awaiting response (find overdue ones!)
- `acknowledge_message(message_id, note)` - ACK receipt of a message (as recipient)
- `mark_processing(message_id, estimated_minutes)` - Tell sender you're working on it

### Message Types

| Type | Purpose |
|------|---------|
| `task_ready` | **START** an agent's work loop (use to kickoff agents) |
| `info` | General information |
| `update` | Status updates |
| `complete` | Completion notification |
| `warning` | Warnings |
| `issue` | Bug reports / issues |

### Priority Levels

| Priority | When to Use |
|----------|-------------|
| `urgent` | Needs IMMEDIATE attention (bugs, blockers) |
| `high` | Important, process ASAP (questions, issues, completion) |
| `normal` | Standard priority (default) |
| `low` | FYI info, not urgent |
{% endmacro %}


{% macro starting_agents() %}
### ⚠️ CRITICAL: Starting Other Agents

**To START an agent's work loop, you MUST use `msg_type="task_ready"`:**
```python
send_message(to_agent="design", content="...", msg_type="task_ready", priority="high")
```

**DO NOT use `msg_type="info"` or `msg_type="update"` to start agents!** Those are for updates only.
Only `task_ready` triggers an agent to start working!
{% endmacro %}


{% macro communication_examples() %}
### Communication Examples

```python
# Start an agent's work loop
send_message(
    to_agent="design", 
    content="Requirements ready. Please create specs.",
    msg_type="task_ready",
    priority="high"
)

# Ask a question
ask_agent(agent_id="backend", question="What is the response format for GET /api/flights?")

# Send update
send_message(to_agent="frontend", content="API routes are ready", msg_type="update")

# Report an issue
report_issue(
    issue="Login returns 500 error",
    assign_to="backend",
    severity="critical"
)

# Broadcast to all
broadcast(message="Design phase complete. All specs in /design/")

# Check messages
check_inbox()
```
{% endmacro %}


{% macro message_tracking() %}
### Message Status Tracking (RECOMMENDED!)

Use these tools to track if your messages were received and processed:

**1. Check status of a sent message:**
```python
# After sending an important message:
result = send_message(to_agent="frontend", content="Fix cart bug", msg_type="issue", priority="urgent")
msg_id = result["message_id"]

# Later, check if they received it:
status = get_message_status(message_id=msg_id)
# Returns: {"status": "delivered/read/processing/responded", "is_overdue": True/False}
```

**2. Get all pending replies:**
```python
# Check all messages awaiting response:
pending = get_pending_replies()
# Returns: {"pending": [...], "overdue_count": 2}

# If overdue, follow up:
for msg in pending["pending"]:
    if msg["is_overdue"]:
        send_message(
            to_agent=msg["to"], 
            content=f"Please respond to my earlier message ({msg['type']})",
            priority="high"
        )
```

**3. Acknowledge receipt (as recipient):**
```python
# When you receive an important message, acknowledge it:
acknowledge_message(message_id=msg_id, note="Working on it now")
```

**4. Mark that you're processing (as recipient):**
```python
# Let sender know you're actively working on their issue:
mark_processing(message_id=msg_id, estimated_minutes=10, status_note="Investigating root cause")
```

**Why use these tools?**
- Sender knows if message was delivered/read
- Prevents duplicate messages
- Helps identify unresponsive agents
- Improves coordination and reduces wait time
{% endmacro %}


{% macro api_contract_sync() %}
## API Contract Synchronization (CRITICAL!)

**PROBLEM:** Frontend and Backend frequently have API mismatches:
- Different function/endpoint names (`listRestaurants` vs `getRestaurants`)
- Different response formats (`{data: items}` vs `{items: [...]}`)
- Different file/page names (`Home.jsx` vs `HomePage.jsx`)
- Missing exports in api.js

**SOLUTION:** Before implementing, Backend and Frontend MUST agree on API contract!

### Backend Agent: MUST Announce API Details

After implementing each endpoint, send a detailed message:

```python
send_message(
    to_agent="frontend",
    content="""API Contract for Restaurants:

## Endpoints
- GET /api/restaurants -> {success: true, data: {items: [...], pagination: {...}}}
- GET /api/restaurants/:id -> {success: true, data: {...restaurant}}
- GET /api/restaurants/:id/menu -> {success: true, data: {items: [...menu_items]}}

## Response Format
All responses wrapped: {success: bool, data: {...}, error?: {...}}
Lists always in: data.items (NOT data directly)

## Auth
Protected endpoints return 401 with {success: false, error: {message: "..."}}
Guest endpoints work without token

## Function Names (for frontend api.js)
- listRestaurants() -> GET /api/restaurants
- getRestaurant(id) -> GET /api/restaurants/:id
- getRestaurantMenu(id) -> GET /api/restaurants/:id/menu

## Error Codes
- 409 CART_RESTAURANT_MISMATCH: Cart from different restaurant
""",
    msg_type="update",
    priority="high"
)
```

### Frontend Agent: MUST Confirm Before Implementing

```python
# BEFORE writing api.js, ASK backend:
ask_agent(
    agent_id="backend",
    question="""Please confirm API contract:
1. What is the exact endpoint path for listing restaurants?
2. What is the response wrapper format?
3. What function name should I use in api.js?
4. How should I handle 401 for unauthenticated users?"""
)

# WAIT for answer before implementing!
check_inbox(from_agent="backend")
```

### Design Agent: MUST Define Consistent Names

In spec.api.json, ALWAYS include:

```json
{
  "endpoints": {
    "/api/restaurants": {
      "method": "GET",
      "frontendFunctionName": "listRestaurants",
      "responseFormat": "{success, data: {items, pagination}}"
    }
  },
  "conventions": {
    "responseWrapper": "{success: boolean, data: T}",
    "listFormat": "data.items array",
    "errorFormat": "{success: false, error: {message, code}}"
  }
}
```

In spec.ui.json, ALWAYS use consistent page names:

```json
{
  "pages": {
    "HomePage.jsx": {"route": "/", "imports": ["listRestaurants"]},
    "RestaurantPage.jsx": {"route": "/restaurants/:id", "imports": ["getRestaurant"]}
  }
}
```

### Checklist Before Implementing

**Backend before coding:**
- [ ] Read spec.api.json for endpoint definitions
- [ ] Announce response format to frontend via send_message
- [ ] Document function names frontend should use

**Frontend before coding:**
- [ ] Ask backend for exact API contract
- [ ] Wait for confirmation on response format
- [ ] Use EXACT function names from spec/backend message
- [ ] Create api.js exports matching agreed names
{% endmacro %}

