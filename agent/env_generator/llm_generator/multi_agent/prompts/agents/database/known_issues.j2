{# Database Agent: Known Issues and Solutions #}

{% macro known_issues() %}
## KNOWN ISSUES & SOLUTIONS (CRITICAL - Apply These!)

### 1. PostgreSQL Version Lock-in
**Problem**: Changing PostgreSQL version causes "database files incompatible" error.
**Solution**: Always specify explicit version in Dockerfile and NEVER change it:
```dockerfile
# Use specific version - changing this breaks existing volumes!
FROM postgres:16-alpine
ENV POSTGRES_INITDB_ARGS="--encoding=UTF-8 --locale=C"
COPY init/ /docker-entrypoint-initdb.d/
```
**IMPORTANT**: If using postgres:16, keep it as 16. Never change without warning users to delete volumes.

### 2. Init Script Execution Order
**Problem**: Foreign key constraints fail because tables created out of order.
**Solution**: Use numbered prefixes for execution order:
```
app/database/init/
├── 01_schema.sql    # Tables with dependencies first
├── 02_seed.sql      # Test data after all tables exist
└── 03_functions.sql # Optional: stored procedures
```
SQL files execute in alphabetical order, so `01_` runs before `02_`.

### 3. Case Sensitivity in Column Names
**Problem**: Backend uses `createdAt` but SQL creates `created_at`.
**Solution**: ALWAYS use snake_case in SQL and document in notification:
```sql
CREATE TABLE flights (
  id SERIAL PRIMARY KEY,
  departure_city VARCHAR(100) NOT NULL,
  price_cents INTEGER NOT NULL,  -- NOT priceCents
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```
Then notify backend: `send_message(to_agent="backend", content="All columns use snake_case")`

### 4. Price Storage - Use Cents!
**Problem**: Floating point errors with decimal prices.
**Solution**: ALWAYS store prices in cents as INTEGER:
```sql
price_cents INTEGER NOT NULL  -- $19.99 stored as 1999
```

### 5. UUID vs SERIAL for IDs
**Problem**: Inconsistent ID types cause join failures.
**Solution**: Choose ONE approach and be consistent:
```sql
-- Option A: SERIAL (simple, auto-increment)
id SERIAL PRIMARY KEY

-- Option B: UUID (distributed-friendly)
id UUID PRIMARY KEY DEFAULT gen_random_uuid()
```
Document your choice when notifying backend!

### 6. Realistic Seed Data
**Problem**: Empty tables cause frontend to show blank pages during testing.
**Solution**: Include meaningful test data for ALL tables (at least 10-20 rows per main entity).

### 7. Image URLs - NEVER Use Unsplash Source API! (CRITICAL!)
**Problem**: `https://source.unsplash.com/...` URLs return 404 - THIS SERVICE WAS DEPRECATED IN 2023!
**Symptom**: All images show blank/broken in UI.

**NEVER use these (DEPRECATED/BROKEN):**
```sql
-- WRONG - These URLs DO NOT WORK!
'https://source.unsplash.com/800x600/?pizza'
'https://source.unsplash.com/1200x800/?food'
```

**USE these instead:**
```sql
-- Option 1: Lorem Picsum (RECOMMENDED - always works)
'https://picsum.photos/seed/pizza1/800/600'   -- seed ensures consistent image
'https://picsum.photos/seed/burger2/1200/800'
'https://picsum.photos/800/600'               -- random image

-- Option 2: Placeholder.co (simple solid color)
'https://placehold.co/800x600/orange/white?text=Pizza'
'https://placehold.co/1200x800/blue/white?text=Restaurant'

-- Option 3: Direct Unsplash image URLs (with specific photo ID)
'https://images.unsplash.com/photo-1565299624946-b28f40a0ae38?w=800&h=600&fit=crop'
```

**Best Practice for Food/Restaurant Projects:**
```sql
-- Use picsum with unique seeds for variety:
INSERT INTO restaurants (name, cover_image_url) VALUES
  ('Pizza Place', 'https://picsum.photos/seed/rest1/1200/800'),
  ('Burger Joint', 'https://picsum.photos/seed/rest2/1200/800'),
  ('Taco Shop', 'https://picsum.photos/seed/rest3/1200/800');

INSERT INTO menu_items (name, image_url) VALUES
  ('Margherita', 'https://picsum.photos/seed/item1/800/600'),
  ('Pepperoni', 'https://picsum.photos/seed/item2/800/600');
```
{% endmacro %}


{% macro sql_syntax_rules() %}
## PostgreSQL Syntax Rules (CRITICAL - AVOID COMMON ERRORS)

**Array syntax in JSONB:**
```sql
-- WRONG (JavaScript syntax - will fail!)
jsonb_build_object('tags', ['tag1', 'tag2'])

-- CORRECT (PostgreSQL syntax)
jsonb_build_object('tags', jsonb_build_array('tag1', 'tag2'))
-- or
jsonb_build_object('tags', to_jsonb(ARRAY['tag1', 'tag2']))
```

**Password hashing for test users:**
```sql
-- Use a VALID bcrypt hash (cost factor 10)
-- This hash = 'admin123'
'$2a$10$rQEY1f.bqRm2e1HnO8bKLOrLvBKwKBHHJXKRxhBqXTwN8xKqjVJWe'
```
**IMPORTANT:** These hashes MUST be compatible with `bcrypt.compare()` in Node.js!
{% endmacro %}


{% macro advanced_issues() %}
## Advanced Issues (From Production Logs)

### 1. Use pgcrypto for Password Hashing in Seed
**Problem**: Hardcoded bcrypt hashes may not work.
**Solution**: Generate bcrypt hashes dynamically:
```sql
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

INSERT INTO users (id, email, password_hash, ...) VALUES
  (gen_random_uuid(), 'admin@test.com', crypt('admin123', gen_salt('bf', 10)), ...);
```

### 2. Enum Type Casting in Seed Data
**Problem**: INSERT fails with enum type mismatch.
**Solution**: Explicitly cast string literals to enum types:
```sql
-- WRONG:
INSERT INTO cart_items (item_type) VALUES ('flight');

-- CORRECT:
INSERT INTO cart_items (item_type) VALUES ('flight'::cart_item_type);
```

### 3. SQL Window Functions in Seed
**Problem**: Window functions in INSERT cause syntax errors.
**Solution**: Use CTEs or subqueries instead:
```sql
-- WRONG:
INSERT INTO flights (...) VALUES
  ((row_number() OVER ()), ...);

-- CORRECT (use CTE):
WITH flight_data AS (
  SELECT row_number() OVER () as rn, ...
)
INSERT INTO flights (...) SELECT ... FROM flight_data;
```

### 4. UUID Foreign Key References
**Problem**: Foreign key insert fails because referenced UUID doesn't exist.
**Solution**: Insert parent records first, use subqueries for FK values:
```sql
INSERT INTO flights (origin_location_id, ...) VALUES
  ((SELECT id FROM locations WHERE iata_code = 'JFK'), ...);
```

### 5. Database Volume Persistence
**Problem**: Schema/seed changes not applied because Docker volume already initialized.
**Solution**: Tell UserAgent to run `docker compose down -v` to remove volumes before rebuild.

### 6. Seed Data bcrypt Hash Compatibility with Node.js
**Problem**: Login returns 401 for seeded users, but newly registered users work.
**Cause**: bcrypt hash generated by PostgreSQL `crypt()` may differ from Node.js bcrypt format.
**Solution**: Use pre-computed Node.js-compatible bcrypt hashes:
```sql
-- These hashes are generated with Node.js bcrypt (cost 10)
-- password: 'admin123' -> '$2b$10$...'
-- password: 'test123' -> '$2b$10$...'

-- Generate valid hashes in Node.js first:
-- const bcrypt = require('bcryptjs');
-- console.log(bcrypt.hashSync('admin123', 10));

INSERT INTO users (email, password_hash, ...) VALUES
  ('admin@test.com', '$2b$10$rQEY1f.bqRm2e1HnO8bKLOrLvBKwKBHHJXKRxhBqXTwN8xKqjVJWe', ...);
```
**CRITICAL**: PostgreSQL's `crypt()` with `gen_salt('bf')` produces `$2a$` hashes, which SHOULD work but sometimes don't. Use `$2b$` prefix for guaranteed Node.js compatibility.

### 7. Seed Data Email Uniqueness
**Problem**: Seed fails with "duplicate key value violates unique constraint".
**Solution**: 
1. Use `ON CONFLICT DO NOTHING` for idempotent seeds:
```sql
INSERT INTO users (email, ...) VALUES ('admin@test.com', ...)
ON CONFLICT (email) DO NOTHING;
```
2. Or add unique identifiers to test emails:
```sql
INSERT INTO users (email, ...) VALUES 
  ('admin-seed-1@test.com', ...),
  ('user-seed-2@test.com', ...);
```

### 8. Seed Data Must Match API Response Expectations
**Problem**: Frontend displays blank or undefined values from seed data.
**Cause**: Seed data missing required fields that API returns.
**Solution**: Seed ALL columns that appear in API responses:
```sql
-- If API returns { name, description, price_cents, image_url, rating }
-- Then seed MUST include all these fields, not NULL:
INSERT INTO hotels (name, description, price_cents, image_url, rating) VALUES
  ('Test Hotel', 'A nice place to stay', 15000, 'https://placehold.co/300x200', 4.5);
```

### 9. Test Data Variety for UI Testing
**Problem**: UserAgent can't test search/filter because all seed data is identical.
**Solution**: Create diverse test data:
```sql
-- Flights: different prices, dates, routes
INSERT INTO flights (price_cents, depart_at, origin, dest) VALUES
  (15000, '2026-01-15 08:00', 'SFO', 'LAX'),  -- Cheap morning
  (45000, '2026-01-15 18:00', 'SFO', 'NYC'),  -- Expensive evening
  (25000, '2026-01-20 12:00', 'LAX', 'CHI');  -- Mid-price midday

-- Hotels: different star ratings, locations, amenities
INSERT INTO hotels (name, star_rating, nightly_price_cents, city) VALUES
  ('Budget Inn', 2, 8000, 'Los Angeles'),
  ('Luxury Resort', 5, 50000, 'San Francisco'),
  ('Business Hotel', 4, 20000, 'New York');
```

### 10. Orders Table Foreign Key Constraints (CRITICAL for Checkout!)
**Problem**: Orders table requires address_id and payment_method_id NOT NULL, but new users have none → checkout fails with FK violation.
**Symptom**: `POST /api/orders` returns 500 with "null value in column address_id violates not-null constraint".
**Solutions** (coordinate with backend):

**Option A: Allow NULL for these columns (simplest)**
```sql
-- In 01_schema.sql - make columns nullable
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  address_id UUID REFERENCES addresses(id),  -- No NOT NULL
  payment_method_id UUID REFERENCES payment_methods(id),  -- No NOT NULL
  status order_status NOT NULL DEFAULT 'pending',
  total_cents INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Option B: Seed default address/payment for test user**
```sql
-- In 02_seed.sql - after user insert
INSERT INTO addresses (id, user_id, label, line1, city, state, postal_code, is_default) VALUES
  ('00000000-0000-0000-0000-000000000101', '00000000-0000-0000-0000-000000000001', 'Home', '123 Main St', 'San Francisco', 'CA', '94102', true);

INSERT INTO payment_methods (id, user_id, brand, last4, exp_month, exp_year, is_default) VALUES
  ('00000000-0000-0000-0000-000000000201', '00000000-0000-0000-0000-000000000001', 'VISA', '4242', 12, 2030, true);
```

**Option C: Use trigger to auto-create defaults on user registration**
```sql
CREATE OR REPLACE FUNCTION create_user_defaults()
RETURNS TRIGGER AS $$
BEGIN
  -- Create default address placeholder
  INSERT INTO addresses (user_id, label, line1, city, state, postal_code, is_default)
  VALUES (NEW.id, 'Default', 'Please update your address', 'City', 'ST', '00000', true);
  
  -- Create placeholder payment method
  INSERT INTO payment_methods (user_id, brand, last4, exp_month, exp_year, is_default)
  VALUES (NEW.id, 'CARD', '0000', 12, 2030, true);
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_user_insert
AFTER INSERT ON users
FOR EACH ROW EXECUTE FUNCTION create_user_defaults();
```

**IMPORTANT**: Inform backend team which option you chose: `send_message(to_agent="backend", content="Orders table: [option chosen]")`

### 11. Cart Table Must Have Proper FK Constraints
**Problem**: Cart operations fail with FK violation when user_id doesn't exist.
**Solution**: Ensure carts table has ON DELETE CASCADE:
```sql
CREATE TABLE carts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)  -- One cart per user
);

CREATE TABLE cart_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cart_id UUID NOT NULL REFERENCES carts(id) ON DELETE CASCADE,
  product_id UUID NOT NULL,
  product_type VARCHAR(50) NOT NULL,  -- 'menu_item', 'grocery', etc.
  quantity INTEGER NOT NULL DEFAULT 1,
  price_cents INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```
{% endmacro %}

