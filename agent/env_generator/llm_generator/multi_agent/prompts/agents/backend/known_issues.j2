{# Backend Agent: Known Issues and Solutions #}

{% macro known_issues() %}
## KNOWN ISSUES & SOLUTIONS (CRITICAL - Apply These!)

### 1. Dockerfile - Native Module Build Failures (bcrypt, etc.)
**Problem**: `npm install` fails with bcrypt compilation errors in Alpine.
**Solution**: Add build dependencies in Dockerfile:
```dockerfile
RUN apk add --no-cache python3 make g++
RUN npm install --omit=dev --legacy-peer-deps
```

### 2. NPM Peer Dependency Conflicts
**Problem**: `npm install` fails with ERESOLVE peer dependency errors.
**Solution**: Always use `--legacy-peer-deps` flag

### 3. Port Configuration Mismatch
**Problem**: Container exposes wrong port or port mismatch with docker-compose.
**Solution**: Ensure Dockerfile EXPOSE matches docker-compose mapping and server.js PORT

### 4. ESLint Config for ES Modules
**Problem**: ESLint fails with "type: module" packages.
**Solution**: Use flat config (eslint.config.js, NOT .eslintrc):
```javascript
import js from '@eslint/js';
export default [
  js.configs.recommended,
  { languageOptions: { ecmaVersion: 2022, sourceType: 'module' } }
];
```

### 5. ESLint 'process' and 'console' Not Defined
**Problem**: ESLint errors: `'process' is not defined`, `'console' is not defined`
**Cause**: Node.js globals not configured in ESLint.
**Solution**: Add globals to eslint.config.js:
```javascript
import js from '@eslint/js';
import globals from 'globals';

export default [
  js.configs.recommended,
  {
    languageOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      globals: {
        ...globals.node,  // Adds process, console, __dirname, etc.
      }
    }
  }
];
```
**Quick fix without globals package:**
```javascript
languageOptions: {
  globals: {
    process: 'readonly',
    console: 'readonly',
    __dirname: 'readonly',
    __filename: 'readonly',
    Buffer: 'readonly',
  }
}
```

### 6. QA/Testing Auth Bypass (CRITICAL for UserAgent Testing!)
**Problem**: JWT tokens are redacted in tool outputs, blocking testing of protected endpoints.
**Symptom**: UserAgent can't test `/auth/me`, `/cart`, `/favorites` because tokens are masked.
**Solution**: Implement QA-only bypass in auth middleware:
```javascript
// middleware/auth.js
const isTestMode = process.env.DB_MODE === 'memory' || process.env.NODE_ENV === 'test';

export const requireAuth = (req, res, next) => {
  // QA bypass for testing
  if (isTestMode) {
    const testUser = req.headers['x-test-user'];
    const authHeader = req.headers.authorization;
    
    // Accept Bearer test or test-token
    if (authHeader === 'Bearer test' || authHeader === 'Bearer test-token') {
      req.user = { id: 'test-user-1', email: 'test@test.com', role: 'user' };
      return next();
    }
    
    // Accept X-Test-User header
    if (testUser) {
      req.user = { id: testUser, email: `${testUser}@test.com`, role: 'user' };
      return next();
    }
  }
  
  // Normal JWT validation...
};
```
**IMPORTANT**: Also update /auth/me to use req.user directly:
```javascript
router.get('/me', requireAuth, (req, res) => {
  // Use req.user set by middleware, don't re-query!
  res.json({ success: true, data: { user: req.user } });
});
```

### 7. API Route Prefix Consistency (/api vs no prefix)
**Problem**: Some routes use `/api/flights`, others use `/flights` directly.
**Symptom**: 404 errors for some endpoints, proxy confusion.
**Solution**: Pick ONE convention and stick to it:
```javascript
// server.js - Option A: All routes under /api
app.use('/api/auth', authRoutes);
app.use('/api/flights', flightsRoutes);
app.use('/api/hotels', hotelsRoutes);

// server.js - Option B: No /api prefix
app.use('/auth', authRoutes);
app.use('/flights', flightsRoutes);
```
**CRITICAL**: Inform frontend which convention is used via `send_message(to_agent="frontend")`!
{% endmacro %}


{% macro database_issues() %}
## Database-Related Issues

### 1. db.js Must Export `query` Function
**Problem**: ESM import error - `import { query }` fails because db.js doesn't export `query`.
**Solution**: Always provide both named and default exports:
```javascript
// Named export for destructured imports
export const query = (text, params) => pool.query(text, params);
export { pool };

// Default export for legacy imports
export default pool;
```

### 2. DATABASE_URL Must Take Precedence
**Problem**: db.js ignores DATABASE_URL and uses hardcoded config.
**Solution**: Check for DATABASE_URL first:
```javascript
const pool = process.env.DATABASE_URL 
  ? new Pool({ connectionString: process.env.DATABASE_URL })
  : new Pool({ host: 'database', port: 5432, ... });
```

### 3. Common SQL Column Name Mismatches
**Problem**: SQL 500 errors due to referencing non-existent columns.
**Known issues:**
- `carts.status` - May not exist
- `hotel_photos.created_at` - May not exist
- `flights.depart_time` vs `flights.depart_at`
**Solution**: ALWAYS call `db_schema(table_name)` before writing SQL queries.
{% endmacro %}


{% macro server_issues() %}
## Server Issues

### 1. Server Port Consistency
**Problem**: Port mismatch between server.js, Dockerfile, and docker-compose.yml.
**Solution**: Always use environment variable with consistent default:
```javascript
// server.js
const PORT = Number(process.env.PORT || 3000);
// Dockerfile: EXPOSE 3000
// docker-compose.yml: "8080:3000"
```

### 2. Express Route Mounting
**Problem**: Routes not accessible at expected paths.
**Solution**: Ensure consistent mounting:
```javascript
// server.js
app.use('/api/auth', authRoutes);
app.use('/api/flights', flightsRoutes);
app.use('/api/trips', tripsRoutes);
app.use('/api/bookings', tripsRoutes);  // Alias for compatibility
```
{% endmacro %}


{% macro code_consistency_issues() %}
## Code Consistency Issues (CRITICAL - PREVENT BUILD/RUNTIME ERRORS)

### 1. ESM Export Naming Consistency
**Problem**: Docker image exports different function name than source code shows.
**Example**: Code has `optionalAuth` but container exports `requireAuthOptional`.
**Solution**: Use CONSISTENT naming AND export ALL variants:
```javascript
// middleware/auth.js - Export with consistent naming
export const requireAuth = (req, res, next) => { ... };
export const optionalAuth = (req, res, next) => { ... };

// Also provide aliases for flexibility
export const requireAuthMiddleware = requireAuth;
export const authRequired = requireAuth;
```

### 2. Database Column Names MUST Match Code (CRITICAL!)
**Problem**: Backend SQL uses `first_name, last_name` but DB has `full_name` → 500 errors.
**Solution**: 
1. **ALWAYS** read `design/spec.database.json` before writing ANY SQL query
2. Use `db_schema(table_name)` to verify actual column names
3. Common mismatches:
   - `first_name/last_name` → Should be `full_name` (single column)
   - `password` → Should be `password_hash`
   - `createdAt` → Should be `created_at` (snake_case!)

```javascript
// WRONG - Will cause 500 error!
const { rows } = await query(
  'SELECT first_name, last_name FROM users WHERE id = $1',
  [userId]
);

// CORRECT - Use actual DB column names
const { rows } = await query(
  'SELECT full_name, email, phone FROM users WHERE id = $1',
  [userId]
);
```

### 3. Middleware Must Export ALL Functions
**Problem**: Route imports `optionalAuth` but middleware only exports `requireAuth`.
**Solution**: Export all middleware variants that routes might need:
```javascript
// middleware/auth.js
export const requireAuth = (req, res, next) => { ... };

// Optional auth - passes through if no token, validates if present
export const optionalAuth = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return next();  // No token = anonymous, continue
  // Validate token if present...
};
```

### 4. Auth Response Must Match Frontend Expectations
**Problem**: Frontend expects `user.fullName` but backend returns `user.full_name`.
**Solution**: Transform DB response to camelCase for API:
```javascript
// In auth routes
const user = rows[0];
res.json({
  user: {
    id: user.id,
    email: user.email,
    fullName: user.full_name,  // Transform snake_case → camelCase
    phone: user.phone
  },
  token: jwt.sign(...)
});
```
{% endmacro %}


{% macro sql_best_practices() %}
## SQL Query Best Practices (PREVENT 500 ERRORS)

**Before writing ANY SQL query:**
1. Use `db_schema()` tool to verify actual table columns
2. Cross-reference with `design/spec.database.json`
3. NEVER assume column names - always verify first

**Common column naming patterns to check:**
- Time fields: `created_at`, `updated_at`, `depart_at`, `arrive_at` (NOT `depart_time`)
- Price fields: `*_cents` suffix (e.g., `price_cents`, `base_price_per_day_cents`)
- Foreign keys: `*_id` suffix (e.g., `location_id`, `user_id`)

**If you get a 500 error with "column does not exist":**
1. Call `db_schema()` to see actual columns
2. Fix the column name in your SQL query
3. Test with `test_api()` before marking complete
{% endmacro %}


{% macro api_response_format() %}
## API Response Format Consistency (CRITICAL!)

### 1. Response Wrapper Must Be Consistent Across ALL Endpoints
**Problem**: Frontend shows "empty" even though backend has data (e.g., Cart shows empty but items exist).
**Root Cause**: Different endpoints use different wrapper formats:
- `/cart` returns `{ cart: { items: [...] } }`
- `/flights` returns `{ items: [...] }`
- `/hotels` returns `{ data: [...] }`

**Solution**: Use CONSISTENT response format across ALL endpoints:
```javascript
// utils/response.js - Use this for ALL list responses
export const successResponse = (res, data, message = 'Success') => {
  res.json({
    success: true,
    data: data,  // ALWAYS use 'data' key
    message
  });
};

// For paginated lists:
export const paginatedResponse = (res, items, pagination) => {
  res.json({
    success: true,
    data: { items, ...pagination }  // items inside data.items
  });
};

// For single item:
export const itemResponse = (res, item, resourceName = 'item') => {
  res.json({
    success: true,
    data: item  // Single item directly in data
  });
};
```

### 2. Cart API Specific Response Format
**Problem**: Cart UI doesn't update after add/remove operations.
**Solution**: Cart endpoints MUST return consistent structure:
```javascript
// GET /api/cart
res.json({
  success: true,
  data: {
    id: cart.id,
    items: cart.items || [],
    total_cents: calculateTotal(cart.items)
  }
});

// POST /api/cart/items (add item)
res.json({
  success: true,
  data: {
    cart: { id, items, total_cents },  // Full cart
    added_item: newItem  // What was added
  }
});
```

### 3. Verify Response Format Before Marking Complete
**Checklist for every API endpoint:**
1. List endpoints: Return `{ success, data: { items: [...], pagination } }`
2. Single item endpoints: Return `{ success, data: { ...item } }`
3. Error responses: Return `{ success: false, error: { message, code } }`
4. Test with `test_api()` and verify response structure matches spec
{% endmacro %}


{% macro memory_mode_issues() %}
## Memory Mode (Non-Docker Testing) Issues

### 1. Memory DB Requires Different SQL Handling
**Problem**: SQL queries work in PostgreSQL but fail in memory mode.
**Solution**: Use memory adapter that handles common queries:
```javascript
// memory/db.js
const handlers = {
  // Cart queries need special handling
  'INSERT INTO cart_items': (text, params) => {
    const id = params[0] || uuid();
    memoryStore.cart_items.push({ id, ...parseParams(params) });
    return { rows: [{ id }] };
  },
  'SELECT * FROM cart_items WHERE cart_id': (text, params) => {
    const items = memoryStore.cart_items.filter(i => i.cart_id === params[0]);
    return { rows: items };
  }
};
```

### 2. Memory Mode Cart Operations
**Problem**: Cart shows empty in memory mode but works in Docker.
**Common issues:**
- `getOrCreateCart` uses INSERT that memory adapter doesn't support
- `addToCart` UUID generation differs between modes
- `getCartItems` JOIN syntax not supported

**Solution**: Add explicit handlers for cart operations:
```javascript
// In cart.js routes - detect memory mode
const isMemoryMode = process.env.DB_MODE === 'memory';

if (isMemoryMode) {
  // Use simplified in-memory operations
  cart = await memoryDb.getOrCreateCart(userId);
} else {
  // Use PostgreSQL
  cart = await query('INSERT INTO carts...');
}
```
{% endmacro %}


{% macro auth_and_cart_issues() %}
## Auth & Cart Issues (CRITICAL - From Production Logs)

### 1. requireAuth Must Verify User Exists in DB (FK Violation Prevention!)
**Problem**: JWT token contains user_id that no longer exists in DB → cart operations cause FK violation (500 error).
**Symptom**: `POST /api/cart/items` returns 500 with "violates foreign key constraint carts_user_id_fkey".
**Root Cause**: Auth middleware decodes JWT but doesn't verify user still exists in database.
**Solution**: Add user existence check in requireAuth middleware:
```javascript
// middleware/auth.js
export const requireAuth = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // CRITICAL: Verify user exists in DB before proceeding!
    const { rows } = await query('SELECT id, email, full_name FROM users WHERE id = $1', [decoded.sub || decoded.id]);
    if (rows.length === 0) {
      return res.status(401).json({ error: 'User no longer exists' });
    }
    
    req.user = rows[0];  // Use fresh DB data, not just token claims
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired' });
    }
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

### 2. Cart Routes Must Handle Missing User Gracefully
**Problem**: Even with auth, cart INSERT can fail if user was deleted between auth check and query.
**Solution**: Use UPSERT pattern and catch FK errors:
```javascript
// routes/cart.js
router.post('/items', requireAuth, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Get or create cart with FK safety
    let cart;
    try {
      const result = await query(
        `INSERT INTO carts (user_id) VALUES ($1) 
         ON CONFLICT (user_id) DO UPDATE SET updated_at = NOW()
         RETURNING id`,
        [userId]
      );
      cart = result.rows[0];
    } catch (error) {
      if (error.code === '23503') {  // FK violation
        return res.status(401).json({ error: 'User account not found' });
      }
      throw error;
    }
    
    // Continue with cart item insertion...
  } catch (error) {
    // ...
  }
});
```

### 3. Orders Require Address and Payment Method
**Problem**: `POST /api/orders` fails because orders.address_id and orders.payment_method_id are NOT NULL but new users have none.
**Symptom**: 500 error "null value in column address_id violates not-null constraint".
**Solutions** (pick one):
```javascript
// Option A: Create default address/payment on registration
router.post('/register', async (req, res) => {
  // After user INSERT...
  const userId = newUser.id;
  
  // Create default address
  await query(
    `INSERT INTO addresses (user_id, label, line1, city, state, postal_code, is_default)
     VALUES ($1, 'Default', 'Please update', 'City', 'ST', '00000', true)`,
    [userId]
  );
  
  // Create placeholder payment method
  await query(
    `INSERT INTO payment_methods (user_id, brand, last4, exp_month, exp_year, is_default)
     VALUES ($1, 'CARD', '0000', 12, 2030, true)`,
    [userId]
  );
});

// Option B: Allow NULL in orders (modify schema)
// ALTER TABLE orders ALTER COLUMN address_id DROP NOT NULL;

// Option C: Require address/payment selection in checkout API
router.post('/orders', requireAuth, async (req, res) => {
  const { address_id, payment_method_id, ...orderData } = req.body;
  
  if (!address_id || !payment_method_id) {
    return res.status(400).json({ 
      error: 'Please add a delivery address and payment method before checkout',
      missing: { address_id: !address_id, payment_method_id: !payment_method_id }
    });
  }
  // ...
});
```

### 4. Guest Users Must Get 401, Not 500
**Problem**: Unauthenticated requests to protected endpoints return 500 instead of 401.
**Cause**: Route handler runs before auth middleware properly rejects, or error handler masks auth errors.
**Solution**: Ensure requireAuth is FIRST middleware and returns early:
```javascript
// CORRECT order
router.get('/cart', requireAuth, cartController.getCart);

// In requireAuth - return immediately on auth failure
if (!authHeader) {
  return res.status(401).json({ error: 'Authentication required' });  // RETURN!
}
```

### 5. Respond Promptly to UserAgent Issues
**Problem**: UserAgent reports critical issues but Backend Agent doesn't respond, causing testing timeout.
**Solution**: When you receive an issue from UserAgent:
1. Acknowledge immediately: `send_message(to_agent="user", content="Received issue, investigating...")`
2. Prioritize CRITICAL issues over other work
3. Fix and confirm: `send_message(to_agent="user", content="Fixed: [description]. Please rebuild and test.")`
{% endmacro %}

