{# Code Agents Prompts - Database, Backend, Frontend #}

{# ==================== DATABASE AGENT ==================== #}

{% macro database_system() %}
You are a database expert generating PostgreSQL code.

Your responsibilities:
1. Generate init.sql from database schema
2. Generate seed.sql with test data
3. Create Dockerfile for PostgreSQL
4. Fix database-related issues

CRITICAL: Follow the spec.database.json exactly.
{% endmacro %}


{% macro database_generate_init(schema) %}
Generate PostgreSQL init.sql from this schema.

<DATABASE_SCHEMA>
{{ schema | tojson(indent=2) }}
</DATABASE_SCHEMA>

## Requirements

1. Start with:
```sql
-- Database initialization
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
```

2. For each table:
   - Use the exact column types specified
   - Add all constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL)
   - Create indexes
   - Add triggers for updated_at if the column exists

3. Create tables in correct order (dependencies first)

4. Use proper PostgreSQL syntax:
   - UUID with `gen_random_uuid()`
   - TIMESTAMP WITH TIME ZONE
   - JSONB for flexible data

Output raw SQL only, no markdown code blocks.
{% endmacro %}


{% macro database_generate_seed(schema) %}
Generate PostgreSQL seed.sql for testing.

<DATABASE_SCHEMA>
{{ schema | tojson(indent=2) }}
</DATABASE_SCHEMA>

## Requirements

1. Create realistic test data
2. Include test users (bcrypt hashed passwords):
   - {{ test_email | default('admin@example.com') }} / {{ test_password | default('admin123') }}
   - user@example.com / password123
3. 5-10 records per table minimum
4. Maintain referential integrity
5. Use realistic values (not "test1", "test2")

For bcrypt password hashes, generate appropriate hashes. Example format:
```sql
-- password hash example
'$2a$10$rQEY1f.bqRm2e1HnO8bKLOrLvBKwKBHHJXKRxhBqXTwN8xKqjVJWe'
```

Output raw SQL only, no markdown code blocks.
{% endmacro %}


{% macro database_fix_issue(issue, current_files) %}
Fix this database issue.

<ISSUE>
Title: {{ issue.title }}
Description: {{ issue.description }}
</ISSUE>

<CURRENT_FILES>
{% for path, content in current_files.items() %}
## {{ path }}
```sql
{{ content[:2000] }}
```
{% endfor %}
</CURRENT_FILES>

Provide the fix as JSON:
```json
{
    "file": "init.sql or seed.sql",
    "content": "full corrected SQL content",
    "explanation": "what was wrong and how you fixed it"
}
```
{% endmacro %}


{# ==================== BACKEND AGENT ==================== #}

{% macro backend_system() %}
You are a backend developer generating Node.js/Express API code.

Your responsibilities:
1. Generate server.js with Express setup
2. Generate route handlers for all endpoints
3. Implement authentication middleware
4. Create Dockerfile
5. Fix backend issues

CRITICAL: Follow spec.api.json EXACTLY for:
- Endpoint paths and methods
- Request/response formats
- Response wrapper keys (items, item, etc.)
{% endmacro %}


{% macro backend_generate_server(api_spec, db_tables) %}
Generate Express server.js.

<API_SPEC>
{{ api_spec | tojson(indent=2) }}
</API_SPEC>

<DATABASE_TABLES>
{{ db_tables | tojson(indent=2) }}
</DATABASE_TABLES>

## Requirements

1. Express with proper middleware:
```javascript
const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');

const app = express();
app.use(cors());
app.use(express.json());

const pool = new Pool({
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'app',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres'
});
```

2. Health check endpoint: `GET /health`
3. Import and mount all route files
4. Global error handler
5. Start server on PORT env var or 3000

Output raw JavaScript only, no markdown code blocks.
{% endmacro %}


{% macro backend_generate_routes(resource, endpoints, db_tables) %}
Generate Express routes for: {{ resource }}

<ENDPOINTS>
{{ endpoints | tojson(indent=2) }}
</ENDPOINTS>

<DATABASE_TABLES>
{{ db_tables | tojson(indent=2) }}
</DATABASE_TABLES>

## CRITICAL Requirements

1. Use the EXACT response format from spec:
```javascript
// For list endpoints:
res.json({ items: rows, total: count });

// For single item:
res.json({ item: row });

// For create:
res.status(201).json({ item: newRow });

// For errors:
res.status(400).json({ error: { code: 'VALIDATION_ERROR', message: '...' } });
```

2. Use parameterized queries (prevent SQL injection):
```javascript
const { rows } = await pool.query(
    'SELECT * FROM users WHERE id = $1',
    [req.params.id]
);
```

3. Proper HTTP methods and status codes:
   - GET: 200 (list/detail), 404 (not found)
   - POST: 201 (created), 400 (validation error)
   - PATCH: 200 (updated), 404 (not found)
   - DELETE: 204 (no content), 404 (not found)

4. Auth middleware where required:
```javascript
router.get('/', auth, async (req, res) => { ... });
```

Output raw JavaScript only, no markdown code blocks.
{% endmacro %}


{% macro backend_fix_issue(issue, current_files, api_spec) %}
Fix this backend issue.

<ISSUE>
Title: {{ issue.title }}
Description: {{ issue.description }}
Related Files: {{ issue.related_files | tojson }}
</ISSUE>

<API_SPEC>
{{ api_spec | tojson(indent=2) }}
</API_SPEC>

<CURRENT_FILES>
{% for path, content in current_files.items() %}
## {{ path }}
```javascript
{{ content[:2000] }}
```
{% endfor %}
</CURRENT_FILES>

Common issues:
- 404: Route path doesn't match frontend call
- 405: Wrong HTTP method (PUT vs PATCH)
- 400: Request body validation mismatch
- Response format: Wrong wrapper key (items vs issues)

Provide the fix as JSON:
```json
{
    "files": [
        {"path": "relative/path.js", "content": "full corrected content"}
    ],
    "explanation": "what was wrong and how you fixed it"
}
```
{% endmacro %}


{# ==================== FRONTEND AGENT ==================== #}

{% macro frontend_system() %}
You are a frontend developer generating React applications.

Your responsibilities:
1. Generate React components and pages
2. Implement API service with correct response handling
3. Create responsive, accessible UI
4. Fix frontend issues

CRITICAL: Match API response formats EXACTLY:
- If backend returns { items: [...] }, use data.items
- If backend returns { item: {...} }, use data.item
- NEVER assume the response structure - check spec.api.json
{% endmacro %}


{% macro frontend_generate_app(ui_spec, pages) %}
Generate React App.jsx with routing.

<UI_SPEC>
{{ ui_spec | tojson(indent=2) }}
</UI_SPEC>

<PAGES>
{{ pages | tojson(indent=2) }}
</PAGES>

## Requirements

1. Use React Router v6:
```jsx
import { Routes, Route, Navigate } from 'react-router-dom';
```

2. Include:
   - Auth context for login state
   - Protected route wrapper
   - Layout component with navigation
   - Lazy loading for pages

3. Route structure:
```jsx
<Routes>
    <Route path="/login" element={<Login />} />
    <Route path="/" element={<ProtectedRoute><Layout /></ProtectedRoute>}>
        <Route index element={<Dashboard />} />
        {/* Other routes */}
    </Route>
</Routes>
```

Output raw JSX only, no markdown code blocks.
{% endmacro %}


{% macro frontend_generate_api_service(api_spec) %}
Generate API service that matches the backend EXACTLY.

<API_SPEC>
{{ api_spec | tojson(indent=2) }}
</API_SPEC>

## CRITICAL: Response Handling

```javascript
// Base request function
async function request(path, options = {}) {
    const token = localStorage.getItem('token');
    const res = await fetch(`/api${path}`, {
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...(token && { 'Authorization': `Bearer ${token}` }),
            ...options.headers
        },
        body: options.body ? JSON.stringify(options.body) : undefined
    });
    
    if (!res.ok) {
        const error = await res.json().catch(() => ({ error: { message: 'Request failed' } }));
        throw new Error(error.error?.message || 'Request failed');
    }
    
    return res.json();
}

// For list endpoints - extract from 'items' key:
export async function getItems() {
    const data = await request('/items');
    return data.items || [];  // Backend returns { items: [...] }
}

// For single item - extract from 'item' key:
export async function getItem(id) {
    const data = await request(`/items/${id}`);
    return data.item;  // Backend returns { item: {...} }
}

// For create - extract from 'item' key:
export async function createItem(payload) {
    const data = await request('/items', { method: 'POST', body: payload });
    return data.item;  // Backend returns { item: {...} }
}

// For update - use PATCH, extract from 'item' key:
export async function updateItem(id, payload) {
    const data = await request(`/items/${id}`, { method: 'PATCH', body: payload });
    return data.item;
}

// For delete - no response body:
export async function deleteItem(id) {
    await request(`/items/${id}`, { method: 'DELETE' });
}
```

Generate functions for ALL endpoints in the spec.
Match response_key from each endpoint definition.

Output raw JavaScript only, no markdown code blocks.
{% endmacro %}


{% macro frontend_generate_page(page_spec, api_endpoints) %}
Generate React page component.

<PAGE_SPEC>
{{ page_spec | tojson(indent=2) }}
</PAGE_SPEC>

<RELEVANT_API_ENDPOINTS>
{{ api_endpoints | tojson(indent=2) }}
</RELEVANT_API_ENDPOINTS>

## Requirements

1. Functional component with hooks
2. Proper data fetching with useEffect
3. Loading and error states
4. **Extract data using correct response key:**

```jsx
function ItemList() {
    const [items, setItems] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        async function fetchData() {
            try {
                // API returns { items: [...] }
                const data = await api.getItems();
                setItems(data);  // getItems() already extracts .items
            } catch (e) {
                setError(e.message);
            } finally {
                setLoading(false);
            }
        }
        fetchData();
    }, []);

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error}</div>;
    if (!items.length) return <div>No items found</div>;

    return (
        <ul>
            {items.map(item => (
                <li key={item.id}>{item.name}</li>
            ))}
        </ul>
    );
}
```

Output raw JSX only, no markdown code blocks.
{% endmacro %}


{% macro frontend_fix_issue(issue, current_files, api_spec) %}
Fix this frontend issue.

<ISSUE>
Title: {{ issue.title }}
Description: {{ issue.description }}
Related Files: {{ issue.related_files | tojson }}
</ISSUE>

<API_SPEC>
{{ api_spec | tojson(indent=2) }}
</API_SPEC>

<CURRENT_FILES>
{% for path, content in current_files.items() %}
## {{ path }}
```jsx
{{ content[:2000] }}
```
{% endfor %}
</CURRENT_FILES>

Common issues:
- "x.map is not a function": API returns object but code expects array
  - Fix: Extract correct key (data.items vs data directly)
- "Cannot read property of undefined": Wrong response structure
  - Fix: Check API spec for actual response format
- 404 on API call: Frontend path doesn't match backend
  - Fix: Check spec.api.json for correct endpoint path

Provide the fix as JSON:
```json
{
    "files": [
        {"path": "relative/path.jsx", "content": "full corrected content"}
    ],
    "explanation": "what was wrong and how you fixed it"
}
```
{% endmacro %}


{% macro answer_question(agent_type, question, context) %}
You are the {{ agent_type }} agent answering a technical question.

<QUESTION>
{{ question }}
</QUESTION>

<CONTEXT>
{{ context | tojson(indent=2) if context else "No specific context" }}
</CONTEXT>

Provide a helpful, technical answer.
Include code examples when relevant.
If the question reveals an inconsistency with other agents' work, flag it clearly.
{% endmacro %}

